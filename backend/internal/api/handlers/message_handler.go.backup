package handlers

import (
	"context"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/gofiber/fiber/v3"
	"github.com/unforced/parachute-backend/internal/acp"
	"github.com/unforced/parachute-backend/internal/domain/conversation"
	"github.com/unforced/parachute-backend/internal/domain/space"
)

// MessageHandler handles message-related HTTP requests
type MessageHandler struct {
	conversationService *conversation.Service
	spaceService        *space.Service
	acpClient           *acp.ACPClient
	// Session management: one ACP session per Conversation
	// Map: ConversationID -> SessionID
	conversationSessions map[string]string
	// Track if we've started a listener for this conversation
	activeListeners map[string]bool
	sessionMu       sync.RWMutex
}

// NewMessageHandler creates a new message handler
func NewMessageHandler(
	conversationService *conversation.Service,
	spaceService *space.Service,
	acpClient *acp.ACPClient,
) *MessageHandler {
	return &MessageHandler{
		conversationService:  conversationService,
		spaceService:         spaceService,
		acpClient:            acpClient,
		conversationSessions: make(map[string]string),
		activeListeners:      make(map[string]bool),
	}
}

// SendMessageRequest represents a request to send a message
type SendMessageRequest struct {
	ConversationID string `json:"conversation_id"`
	Content        string `json:"content"`
}

// SendMessage handles POST /api/messages
// This creates a user message and sends it to ACP
func (h *MessageHandler) SendMessage(c fiber.Ctx) error {
	ctx := c.Context()

	// Parse request
	var req SendMessageRequest
	if err := c.Bind().JSON(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	if req.ConversationID == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "conversation_id is required",
		})
	}

	if req.Content == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "content is required",
		})
	}

	// Get conversation
	conv, err := h.conversationService.GetConversation(ctx, req.ConversationID)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": "Conversation not found",
		})
	}

	// Get space
	spaceObj, err := h.spaceService.GetByID(ctx, conv.SpaceID)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": "Space not found",
		})
	}

	// Create user message
	userMessage, err := h.conversationService.CreateMessage(ctx, conversation.CreateMessageParams{
		ConversationID: req.ConversationID,
		Role:           "user",
		Content:        req.Content,
	})
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to create message",
		})
	}

	// Get conversation history
	messages, err := h.conversationService.ListMessages(ctx, req.ConversationID)
	if err != nil {
		log.Printf("Failed to get message history: %v", err)
		messages = []*conversation.Message{} // Continue with empty history
	}

	// Build prompt with context and send to ACP if available
	if h.acpClient != nil {
		prompt := h.buildPromptWithContext(spaceObj, messages, req.Content)

		// Get or create ACP session for this conversation
		sessionID, isNew, err := h.getOrCreateSession(req.ConversationID, spaceObj.Path)
		if err != nil {
			log.Printf("‚ùå Failed to get/create ACP session: %v", err)
			// Continue without ACP
		} else {
			// Start persistent listener only for new sessions
			if isNew {
				go h.startSessionListener(sessionID, req.ConversationID)
			}

			// Send prompt to ACP (non-blocking)
			go h.sendPrompt(sessionID, prompt)
		}
	}

	// Return user message immediately
	return c.Status(fiber.StatusCreated).JSON(userMessage)
}

// getOrCreateSession gets an existing ACP session for a conversation or creates a new one
// Returns: (sessionID, isNewSession, error)
func (h *MessageHandler) getOrCreateSession(conversationID, workingDir string) (string, bool, error) {
	// Check if we already have a session for this conversation
	h.sessionMu.RLock()
	sessionID, exists := h.conversationSessions[conversationID]
	h.sessionMu.RUnlock()

	if exists {
		log.Printf("‚ôªÔ∏è  Reusing existing session %s for conversation %s", sessionID[:8], conversationID[:8])
		return sessionID, false, nil
	}

	// Create new session
	log.Printf("üÜï Creating new ACP session for conversation %s", conversationID[:8])
	sessionID, err := h.acpClient.NewSession(workingDir, nil)
	if err != nil {
		return "", false, fmt.Errorf("failed to create session: %w", err)
	}

	// Cache the session
	h.sessionMu.Lock()
	h.conversationSessions[conversationID] = sessionID
	h.sessionMu.Unlock()

	log.Printf("‚úÖ Created and cached session %s for conversation %s", sessionID[:8], conversationID[:8])
	return sessionID, true, nil
}

// handleACPResponse handles the ACP response in a background goroutine
func (h *MessageHandler) handleACPResponse(sessionID, prompt, conversationID string) {
	ctx := context.Background()

	if h.acpClient == nil {
		log.Printf("‚ö†Ô∏è  ACP client is nil, cannot handle response")
		return
	}

	// Setup response collection
	fullResponse := ""
	notifCount := 0
	timeout := make(chan bool, 1)

	go func() {
		time.Sleep(30 * time.Second)
		timeout <- true
	}()

	// Send prompt in background so we can listen concurrently
	go func() {
		log.Printf("ü§ñ Sending prompt to ACP session %s", sessionID)
		if err := h.acpClient.SessionPrompt(sessionID, prompt); err != nil {
			log.Printf("‚ùå Failed to send prompt to ACP: %v", err)
			return
		}
		log.Printf("‚úÖ Prompt sent successfully, session/prompt returned")
	}()

	// Start listening immediately (don't wait for prompt to send)
	log.Printf("üéß Starting notification listener for session %s", sessionID)

	wrongSessionCount := 0
	for {
		select {
		case notif := <-h.acpClient.Notifications():
			notifCount++
			log.Printf("üì® Received notification #%d: method=%s", notifCount, notif.Method)

			if notif.Method == "session/update" {
				update, err := acp.ParseSessionUpdate(notif)
				if err != nil {
					log.Printf("‚ùå Failed to parse update: %v", err)
					continue
				}

				if update.SessionID != sessionID {
					wrongSessionCount++
					log.Printf("‚è≠Ô∏è  Skipping update for different session: %s (want %s) [count: %d]", update.SessionID, sessionID, wrongSessionCount)
					// If we see too many wrong sessions, this listener is stale - exit
					if wrongSessionCount >= 5 {
						log.Printf("üõë Too many wrong session notifications, exiting stale listener for %s", sessionID)
						goto done
					}
					continue
				}

				// Reset counter when we get our session
				wrongSessionCount = 0

				log.Printf("üìù Processing update for session %s: %+v", sessionID, update.Update)

				// Extract text from update
				// Check for sessionUpdate field (ACP protocol)
				if sessionUpdate, ok := update.Update["sessionUpdate"].(string); ok {
					log.Printf("   Session update type: %s", sessionUpdate)

					if sessionUpdate == "agent_message_chunk" {
						// Extract text from content field
						if content, ok := update.Update["content"].(map[string]interface{}); ok {
							if text, ok := content["text"].(string); ok {
								fullResponse += text
								log.Printf("   ‚úçÔ∏è  Added text: %q (total: %d chars)", text, len(fullResponse))
							}
						}
					} else if sessionUpdate == "agent_message_complete" {
						// Response complete
						log.Printf("‚úÖ Message complete, total response: %d chars", len(fullResponse))
						goto done
					}
				}
			}
		case <-timeout:
			log.Printf("‚è∞ Timeout waiting for ACP response after 30s")
			goto done
		}
	}

done:
	// Create assistant message
	if fullResponse != "" {
		log.Printf("üíæ Saving assistant response (%d chars) to conversation %s", len(fullResponse), conversationID)
		_, err := h.conversationService.CreateMessage(ctx, conversation.CreateMessageParams{
			ConversationID: conversationID,
			Role:           "assistant",
			Content:        fullResponse,
		})
		if err != nil {
			log.Printf("‚ùå Failed to save assistant message: %v", err)
		} else {
			log.Printf("‚úÖ Assistant message saved successfully")
		}
	} else {
		log.Printf("‚ö†Ô∏è  No response received from ACP (received %d notifications)", notifCount)
	}
}

// buildPromptWithContext builds a prompt including conversation history and CLAUDE.md
func (h *MessageHandler) buildPromptWithContext(
	spaceObj *space.Space,
	messages []*conversation.Message,
	currentPrompt string,
) string {
	prompt := ""

	// Include CLAUDE.md context if it exists
	claudeMD, err := h.spaceService.ReadClaudeMD(spaceObj)
	if err == nil && claudeMD != "" {
		prompt += "# Context from CLAUDE.md\n\n"
		prompt += claudeMD
		prompt += "\n\n---\n\n"
	}

	// Include conversation history (last 10 messages for now)
	if len(messages) > 0 {
		prompt += "# Conversation History\n\n"

		start := 0
		if len(messages) > 10 {
			start = len(messages) - 10
		}

		for _, msg := range messages[start:] {
			if msg.Role == "user" {
				prompt += fmt.Sprintf("User: %s\n\n", msg.Content)
			} else {
				prompt += fmt.Sprintf("Assistant: %s\n\n", msg.Content)
			}
		}

		prompt += "---\n\n"
	}

	// Current prompt
	prompt += currentPrompt

	return prompt
}

// ListMessages handles GET /api/messages?conversation_id=...
func (h *MessageHandler) ListMessages(c fiber.Ctx) error {
	ctx := c.Context()

	conversationID := c.Query("conversation_id")
	if conversationID == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "conversation_id query parameter required",
		})
	}

	messages, err := h.conversationService.ListMessages(ctx, conversationID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to list messages",
		})
	}

	return c.JSON(fiber.Map{
		"messages": messages,
	})
}
